import mongoose from 'mongoose';
import '../config/envLoader';
import Lead from '../models/Lead';

/**
 * Comprehensive Migration: Fix ALL NextGen leads missing proper sourceCode
 * 
 * This migration handles:
 * 1. Leads with sourceHash but wrong sourceCode
 * 2. Leads with no sourceCode at all
 * 3. Leads with no sourceHash (extract from webhook data if available)
 */

async function fixAllNextGenLeads() {
  console.log('üîÑ Starting comprehensive NextGen sourceCode migration...\n');

  try {
    // Connect to MongoDB
    await mongoose.connect(process.env.MONGODB_URI as string);
    console.log('‚úÖ Connected to MongoDB');

    // Find ALL NextGen leads
    const allNextGenLeads = await Lead.find({
      source: 'NextGen'
    }).select('_id name sourceCode sourceHash campaignName notes createdAt');

    console.log(`Found ${allNextGenLeads.length} total NextGen leads\n`);

    let updateCount = 0;
    let skipCount = 0;

    for (const lead of allNextGenLeads) {
      const hasValidSourceCode = lead.sourceCode && 
        lead.sourceCode !== 'NextGen' && 
        lead.sourceCode !== '' &&
        /^[a-zA-Z0-9]{4,8}$/.test(lead.sourceCode); // Hash-like pattern

      if (hasValidSourceCode) {
        console.log(`‚úÖ Lead ${lead.name} already has valid sourceCode: "${lead.sourceCode}"`);
        skipCount++;
        continue;
      }

      console.log(`\nüîß Processing Lead: ${lead.name}`);
      console.log(`  Current sourceCode: "${lead.sourceCode}"`);
      console.log(`  Current sourceHash: "${lead.sourceHash}"`);

      let newSourceCode = null;

      // Strategy 1: Use sourceHash if available
      if (lead.sourceHash && lead.sourceHash.trim() !== '') {
        newSourceCode = lead.sourceHash;
        console.log(`  üìã Using sourceHash: "${newSourceCode}"`);
      }
      // Strategy 2: Extract from notes (webhook data often stored there)
      else if (lead.notes && lead.notes.includes('source_hash')) {
        const hashMatch = lead.notes.match(/source_hash[\":\s]*([a-zA-Z0-9]{4,8})/i);
        if (hashMatch) {
          newSourceCode = hashMatch[1];
          console.log(`  üìã Extracted from notes: "${newSourceCode}"`);
        }
      }
      // Strategy 3: Generate based on creation date (fallback)
      else {
        // Use a deterministic hash based on lead ID for consistency
        const leadIdHash = (lead._id as any).toString().slice(-6);
        newSourceCode = `NG${leadIdHash}`;
        console.log(`  üìã Generated fallback: "${newSourceCode}"`);
      }

      if (newSourceCode) {
        // Update the lead
        const updateData: any = { sourceCode: newSourceCode };
        
        // Also set sourceHash if it was missing
        if (!lead.sourceHash || lead.sourceHash.trim() === '') {
          updateData.sourceHash = newSourceCode;
        }
        
        await Lead.updateOne(
          { _id: lead._id },
          { $set: updateData }
        );
        
        console.log(`  ‚úÖ Updated sourceCode to: "${newSourceCode}"`);
        updateCount++;
      } else {
        console.log(`  ‚ö†Ô∏è  Could not determine sourceCode for lead`);
        skipCount++;
      }
    }

    console.log('\nüìä Migration Summary:');
    console.log(`  Total NextGen leads: ${allNextGenLeads.length}`);
    console.log(`  Updated: ${updateCount}`);
    console.log(`  Skipped (already valid or no data): ${skipCount}`);

    // Verification: Check how many leads now have proper sourceCode
    const fixedLeads = await Lead.countDocuments({
      source: 'NextGen',
      sourceCode: { $exists: true, $ne: null, $ne: '', $ne: 'NextGen' }
    });

    console.log(`\n‚úÖ Verification: ${fixedLeads} NextGen leads now have proper sourceCode`);
    console.log('\n‚úÖ Migration completed successfully');

  } catch (error) {
    console.error('‚ùå Migration failed:', error);
    process.exit(1);
  } finally {
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  }
}

// Run migration
fixAllNextGenLeads(); 