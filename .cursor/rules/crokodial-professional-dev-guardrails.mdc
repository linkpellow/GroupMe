## ✨ CROKODIAL CRM PRIME DIRECTIVE
> **All code must build, test, and run on macOS, Linux, and Windows (Node ≥ 18 LTS) without manual tweaks.**  
> **Every feature must be multi-tenant secure, performant at scale (2,000+ leads), and production-ready.**
> When platform quirks arise, surface them as TODOs and supply a CI‑verified fix.

---

## 🚨 CROKODIAL-SPECIFIC PROFESSIONAL STANDARDS

### Critical Technical Debt Priorities (MANDATORY)
1. **NEVER create monolithic components >500 lines** (current violations: Leads.tsx 6879 lines, Dialer.tsx 3506 lines)
2. **SECURITY CRITICAL: JWT tokens MUST move from localStorage to httpOnly cookies**
3. **PERFORMANCE CRITICAL: Server-side pagination required** (current client-side breaks at 500+ leads)
4. **TESTING MANDATORY: 80% coverage minimum** for all new code (current: ~0% coverage)
5. **MULTI-TENANT SECURITY: Every query MUST include tenantId/userId scope**

### Professional CRM Architecture Standards
- **Feature-Based Organization**: Group by business domain (auth/, leads/, dialer/, campaigns/, integrations/)
- **Single Responsibility**: Each component handles ONE business concern
- **API-First Design**: All business logic in services, controllers only handle HTTP
- **Type Safety**: Strict TypeScript with proper interfaces for all data models
- **Error Boundaries**: Comprehensive error handling with user-friendly messages
- **Multi-Tenant Security**: Built into every data access layer

### Crokodial Technology Stack Context
```typescript
// Current Stack (MUST maintain compatibility)
Frontend: React 18 + TypeScript + Vite + Chakra UI + React Query + Context API
Backend: Node.js + Express + TypeScript + MongoDB + Mongoose
Integrations: Twilio (calls/SMS) + Calendly + NextGen + USHA + Ringy
Deployment: Heroku (Linux) + MongoDB Atlas
Testing: Jest + Cypress (to be implemented)
```

---

## AGENTIC MODES (Enhanced for CRM Development)

### **Planner Mode**: CRM-Focused Analysis
- **Architecture Mapping**: Document lead lifecycle, integration flows, security boundaries
- **Component Breakdown**: Identify monolithic components requiring refactoring
- **Performance Analysis**: Identify client-side filtering, pagination issues, memory leaks
- **Security Review**: Audit JWT storage, API key exposure, multi-tenant violations
- **Integration Mapping**: Document all 3rd-party service dependencies and failure modes

### **Executor Mode**: Production-Ready Implementation  
- **TDD Implementation**: Write failing test → implement → refactor → verify
- **Component Refactoring**: Break down large components systematically
- **Security Implementation**: Implement httpOnly cookies, rate limiting, input validation
- **Performance Optimization**: Implement server-side pagination, React.memo, caching
- **Multi-Tenant Security**: Ensure all queries include proper scoping

### **Mode Switching Protocol**
- Explicitly state which mode is active before major transitions
- Document decision rationale in `.cursor/scratchpad.md`
- Request review before switching from Planner to Executor mode

---

## 1. CROKODIAL CODE MAPPING & DOCUMENTATION

### Canonical Artifacts (git‑tracked)
```bash
docs/
  ├── dependency-graph.svg          # Generated by npm run gen:map
  ├── site/                         # TypeDoc HTML documentation
  ├── api/                          # OpenAPI/Swagger documentation  
  ├── database/                     # MongoDB ERD and schema docs
  ├── integrations/                 # 3rd-party service integration docs
  ├── security/                     # Security audit trails, JWT flows
  └── architecture/                 # Lead lifecycle, call flows, multi-tenant design
```

### CRM-Specific Documentation Requirements
- **Lead Lifecycle Diagrams**: Import → Assignment → Calling → Disposition → Reporting
- **Integration Flow Maps**: Twilio call flow, NextGen webhook processing, Calendly booking flow
- **Multi-Tenant Security Model**: User isolation, data scoping, permission boundaries
- **Performance Benchmarks**: Lead list rendering times, search performance, memory usage
- **Deployment Pipeline**: Heroku deployment steps, Linux lockfile management

### Enhanced Package Scripts
```json
{
  "scripts": {
    "gen:map": "depcruise src --output-type dot | dot -Tsvg -o docs/dependency-graph.svg",
    "gen:docs": "typedoc --entryPoints src --out docs/site",
    "gen:api-docs": "swagger-jsdoc -d docs/swagger.json src/routes/*.ts",
    "gen:db-docs": "node scripts/generate-erd.js",
    "audit:security": "npm audit && snyk test",
    "audit:performance": "lighthouse-ci autorun",
    "audit:multi-tenant": "node scripts/audit-tenant-isolation.js",
    "test:integration": "cypress run --config baseUrl=http://localhost:5173",
    "test:unit": "jest --coverage --passWithNoTests",
    "test:security": "node scripts/test-tenant-isolation.js",
    "lockfile:linux": "./scripts/fix-lockfile-for-linux.sh",
    "deploy:staging": "make deploy-staging",
    "deploy:prod": "make deploy-prod"
  }
}
```

---

## 2. CROKODIAL DEPLOYMENT & VERIFICATION PROTOCOL

### Production Deployment Evidence (Heroku-Specific)
```bash
# Pre-Deployment Checklist
- [ ] npm run lockfile:linux executed (CRITICAL for Heroku)
- [ ] npm audit shows no critical/high vulnerabilities
- [ ] npm test passes with 80%+ coverage  
- [ ] npm run lint passes with zero errors
- [ ] TypeScript compilation successful (tsc --noEmit)
- [ ] Multi-tenant security tests pass
- [ ] Performance benchmarks within acceptable limits

# Deployment Verification Commands
curl -s https://crokodial.com/api/health | jq '.'
curl -s https://crokodial.com/api/leads?limit=1 | jq '.data[0]'
curl -s https://crokodial.com/index.html | grep -o "assets/index-[a-f0-9]*\.js"

# Database & Integration Verification
echo "db.leads.countDocuments()" | mongo $MONGODB_URI
node scripts/test-twilio-integration.js
node scripts/test-nextgen-webhook.js
```

### CRM-Specific Health Checks
- **Lead Import Pipeline**: Verify NextGen webhook processing
- **Twilio Integration**: Test call/SMS functionality  
- **Database Performance**: Query response times under load
- **Multi-Tenant Isolation**: Verify user data separation
- **Memory Usage**: Check for memory leaks in long-running sessions
- **Search Performance**: Verify server-side search with 2,000+ leads

**Record all evidence in `.cursor/scratchpad.md`**

---

## 3. CROKODIAL WORKFLOW & TASK MANAGEMENT

### Enhanced Scratchpad Structure
```markdown
# .cursor/scratchpad.md

## Current Context
- Lead Count: [X] leads in database
- Active Integrations: [NextGen, Twilio, Calendly status]
- Performance Metrics: [Lead list render time, search response time]
- Security Status: [JWT storage method, API key exposure check]

## Background & Motivation
[Current feature/bug context]

## Technical Debt Analysis
- Monolithic Components: [List files >500 lines]
- Security Vulnerabilities: [JWT, API keys, rate limiting status]
- Performance Issues: [Client-side filtering, pagination, memory leaks]
- Testing Coverage: [Current % coverage, missing test areas]

## Task Breakdown (Tiny, Verifiable Steps)
- [ ] [Step 1] - Success Criteria: [Specific measurable outcome]
- [ ] [Step 2] - Success Criteria: [Specific measurable outcome]

## Multi-Tenant Security Checklist
- [ ] All queries include proper tenant scoping
- [ ] No cross-tenant data leakage possible
- [ ] Authentication/authorization properly implemented

## Executor Status & Blockers
[Current implementation status, any blockers requiring planner input]
```

### CRM Development Workflow (TDD-Enhanced)
```typescript
// 1. Write failing test for CRM functionality
describe('LeadCard', () => {
  it('should only display leads for authenticated user', async () => {
    const userALeads = await createMockLeads({ userId: 'userA' });
    const userBLeads = await createMockLeads({ userId: 'userB' });
    
    render(<LeadCard />, { user: { id: 'userA' } });
    
    expect(screen.getByText(userALeads[0].name)).toBeInTheDocument();
    expect(screen.queryByText(userBLeads[0].name)).not.toBeInTheDocument();
  });
});

// 2. Implement with proper multi-tenant security
const getLeads = async (userId: string) => {
  return Lead.find({ userId }).lean(); // Always scoped to user
};

// 3. Refactor with error handling and performance optimization
const getLeads = async (userId: string, page = 1, limit = 50) => {
  try {
    const leads = await Lead.find({ userId })
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(limit)
      .lean();
    return { data: leads, pagination: { page, limit } };
  } catch (error) {
    logger.error('Failed to fetch leads', { userId, error });
    throw new ApiError('Failed to fetch leads', 500);
  }
};
```

---

## 4. CROKODIAL SECURITY & QUALITY STANDARDS

### Critical Security Implementation (Immediate Priority)
```typescript
// JWT Security (MUST IMPLEMENT)
// BEFORE (VULNERABLE):
localStorage.setItem('token', jwt);

// AFTER (SECURE):
// Server: Set httpOnly cookie
res.cookie('auth_token', jwt, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 24 * 60 * 60 * 1000 // 24 hours
});

// Input Validation (ALL ENDPOINTS)
import { z } from 'zod';

const LeadSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email().optional(),
  phone: z.string().regex(/^\+?[\d\s\-\(\)]{10,}$/),
  disposition: z.enum(['New', 'Contacted', 'Qualified', 'Closed']),
  source: z.enum(['NextGen', 'Marketplace', 'Manual']),
  userId: z.string().uuid() // CRITICAL: Always required
});

// Rate Limiting (AUTH & LEAD IMPORT)
import rateLimit from 'express-rate-limit';

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many login attempts, please try again later'
});

// Multi-Tenant Data Access (MANDATORY PATTERN)
class LeadService {
  async getLeads(userId: string, filters: LeadFilters) {
    // ALWAYS include userId in query - NO EXCEPTIONS
    const query = { userId, ...filters };
    return Lead.find(query);
  }
  
  async updateLead(leadId: string, userId: string, updates: LeadUpdates) {
    // ALWAYS verify ownership before update
    const lead = await Lead.findOne({ _id: leadId, userId });
    if (!lead) throw new NotFoundError('Lead not found');
    return Lead.updateOne({ _id: leadId, userId }, updates);
  }
}
```

### Code Quality Standards (Enforced)
- **Component Size**: 500 lines maximum (immediate refactoring required for violations)
- **Function Complexity**: Max 15 cyclomatic complexity
- **Test Coverage**: 80% minimum for new code, 60% for existing (with improvement plan)
- **TypeScript Strict**: No `any` types, proper interfaces for all data structures
- **Error Handling**: Comprehensive try/catch with user-friendly error messages
- **Performance**: Sub-200ms API response times, sub-100ms UI interactions

---

## 5. CROKODIAL ARCHITECTURE PATTERNS

### Feature-Based Directory Structure (MANDATORY)
```typescript
src/
  features/
    leads/
      components/           # LeadCard, LeadList, LeadFilters, LeadActions
        LeadCard/
          index.tsx        # Main component (< 200 lines)
          LeadCard.test.tsx # Comprehensive tests
          types.ts         # Component-specific types
          hooks.ts         # Component-specific hooks
      hooks/               # useLeads, useLeadFilters, useLeadActions
      services/            # leadApi, leadValidation, leadExport
      types/               # Lead, LeadFilter, LeadDisposition interfaces
      utils/               # leadFormatters, leadCalculations
    dialer/
      components/          # CallControls, CallHistory, CallStatus
      hooks/               # useCall, useCallHistory, useCallTimer
      services/            # twilioApi, callTracking, callRecording
      types/               # Call, CallStatus, TwilioConfig
    auth/
      components/          # LoginForm, AuthGuard, UserProfile
      hooks/               # useAuth, usePermissions, useSession
      services/            # authApi, tokenManager, permissionCheck
      types/               # User, AuthState, Permission
    integrations/
      nextgen/             # NextGen API integration
      twilio/              # Twilio call/SMS integration  
      calendly/            # Calendly booking integration
  shared/
    components/            # Button, Modal, DataTable, LoadingSpinner
    hooks/                 # useDebounce, useLocalStorage, useApi
    utils/                 # formatters, validators, constants
    types/                 # ApiResponse, PaginatedData, ErrorResponse
```

### Component Refactoring Strategy (Immediate Implementation)
```typescript
// BEFORE: Leads.tsx (6879 lines) - UNACCEPTABLE
const Leads = () => {
  // 6879 lines of mixed concerns...
};

// AFTER: Properly decomposed (< 200 lines each)
const LeadsPage = () => {
  const { leads, loading, error } = useLeads();
  const { filters, setFilters } = useLeadFilters();
  const { selectedLeads, actions } = useLeadActions();

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorBoundary error={error} />;

  return (
    <LeadsPageLayout>
      <LeadFilters filters={filters} onChange={setFilters} />
      <LeadList 
        leads={leads} 
        selectedLeads={selectedLeads}
        onAction={actions}
      />
      <LeadPagination />
    </LeadsPageLayout>
  );
};

// Each component < 200 lines, single responsibility, fully tested
```

---

## 6. CROKODIAL TESTING STRATEGY

### Testing Requirements (80% Coverage Minimum)
```typescript
// Component Testing (React Testing Library + Jest)
describe('LeadCard', () => {
  it('displays lead information correctly', () => {
    const lead = createMockLead({ 
      name: 'John Doe', 
      phone: '+1234567890',
      userId: 'user123'
    });
    
    render(<LeadCard lead={lead} />, {
      wrapper: ({ children }) => (
        <AuthProvider user={{ id: 'user123' }}>
          {children}
        </AuthProvider>
      )
    });
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('+1234567890')).toBeInTheDocument();
  });

  it('prevents cross-tenant data access', () => {
    const userALead = createMockLead({ userId: 'userA' });
    
    render(<LeadCard lead={userALead} />, {
      wrapper: ({ children }) => (
        <AuthProvider user={{ id: 'userB' }}>
          {children}
        </AuthProvider>
      )
    });
    
    expect(screen.queryByText(userALead.name)).not.toBeInTheDocument();
  });

  it('handles call action correctly', async () => {
    const mockCall = jest.fn();
    const lead = createMockLead();
    
    render(<LeadCard lead={lead} onCall={mockCall} />);
    
    await user.click(screen.getByRole('button', { name: /call/i }));
    expect(mockCall).toHaveBeenCalledWith(lead.phone);
  });
});

// API Testing (Integration Tests)
describe('Leads API', () => {
  it('returns only user-scoped leads', async () => {
    const userA = await createTestUser();
    const userB = await createTestUser();
    
    await createTestLeads([
      { name: 'Lead A1', userId: userA.id },
      { name: 'Lead A2', userId: userA.id },
      { name: 'Lead B1', userId: userB.id }
    ]);
    
    const response = await request(app)
      .get('/api/leads')
      .set('Authorization', `Bearer ${userA.token}`)
      .expect(200);
    
    expect(response.body.data).toHaveLength(2);
    expect(response.body.data.every(lead => lead.userId === userA.id)).toBe(true);
  });
});

// E2E Testing (Cypress)
describe('Lead Management Flow', () => {
  it('allows user to manage their leads only', () => {
    cy.login('user@example.com');
    cy.visit('/leads');
    
    // Verify user can see their leads
    cy.get('[data-testid="lead-card"]').should('be.visible');
    
    // Verify user cannot access other users' leads via URL manipulation
    cy.visit('/leads/other-user-lead-id');
    cy.get('[data-testid="error-message"]').should('contain', 'Access denied');
  });
});
```

---

## 7. CROKODIAL PERFORMANCE STANDARDS

### Performance Requirements (Enforced)
- **Lead List Rendering**: < 200ms for 100 leads, < 500ms for 1000 leads
- **Search Response**: < 300ms server-side search with proper indexing
- **Call Initiation**: < 100ms from click to Twilio API call
- **Page Load**: < 2s initial load, < 500ms subsequent navigation
- **Memory Usage**: < 100MB steady state, no memory leaks in 8-hour sessions

### Performance Implementation Patterns
```typescript
// Server-Side Pagination (MANDATORY for large datasets)
const getLeads = async (userId: string, page = 1, limit = 50) => {
  const skip = (page - 1) * limit;
  
  const [leads, total] = await Promise.all([
    Lead.find({ userId })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit)
      .lean(), // Use lean() for read-only queries
    Lead.countDocuments({ userId })
  ]);
  
  return {
    data: leads,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  };
};

// React Performance Optimization
const LeadCard = React.memo(({ lead, onCall, onEdit }) => {
  const handleCall = useCallback(() => {
    onCall(lead.phone);
  }, [lead.phone, onCall]);
  
  return (
    <Card>
      <CardBody>
        <Text>{lead.name}</Text>
        <Button onClick={handleCall}>Call</Button>
      </CardBody>
    </Card>
  );
});

// Virtual Scrolling for Large Lists (1000+ items)
import { FixedSizeList as List } from 'react-window';

const LeadList = ({ leads }) => {
  const Row = ({ index, style }) => (
    <div style={style}>
      <LeadCard lead={leads[index]} />
    </div>
  );
  
  return (
    <List
      height={600}
      itemCount={leads.length}
      itemSize={120}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

---

## 8. CROKODIAL COMMON PITFALLS & SOLUTIONS

### Deployment Pitfalls (CRITICAL)
- ❌ **NEVER deploy without**: `npm run lockfile:linux` (Heroku will fail)
- ❌ **NEVER assume deploy is live**: Walk the evidence ladder
- ❌ **NEVER skip health checks**: API, DB, Twilio, NextGen webhook verification
- ❌ **NEVER deploy untested**: Multi-tenant security tests must pass

### Development Pitfalls (MANDATORY AVOIDANCE)
- ❌ **NEVER create components >500 lines**: Break down immediately
- ❌ **NEVER use client-side filtering >100 records**: Implement server pagination
- ❌ **NEVER store JWT in localStorage**: Use httpOnly cookies only
- ❌ **NEVER skip multi-tenant scoping**: Every query MUST include userId/tenantId
- ❌ **NEVER hardcode API keys**: Environment variables only
- ❌ **NEVER skip error boundaries**: Leads to white screen of death

### CRM-Specific Pitfalls (BUSINESS CRITICAL)
- ❌ **NEVER process leads without deduplication**: Implement proper lead matching
- ❌ **NEVER allow unlimited imports**: Rate limiting prevents system overload
- ❌ **NEVER skip disposition validation**: Data consistency is critical
- ❌ **NEVER ignore call tracking**: Affects billing and analytics
- ❌ **NEVER skip backup verification**: Customer data loss is unacceptable

---

## GOLDEN RULE (CROKODIAL ENHANCED)

> **Merge only when ALL conditions met:**  
> ✅ tests 80%+ coverage · ✅ multi-tenant security verified · ✅ performance benchmarks met  
> ✅ component size <500 lines · ✅ TypeScript strict compliance · ✅ error handling comprehensive  
> ✅ code map updated · ✅ API documentation current · ✅ deployment evidence recorded  
> ✅ cross-platform compatibility · ✅ Linux lockfile updated · ✅ security audit passed

### Crokodial-Specific Merge Gates (MANDATORY)
```bash
# Pre-Merge Verification Script
#!/bin/bash
echo "🔍 Crokodial Pre-Merge Verification"

# 1. Security Check
echo "Checking multi-tenant security..."
npm run test:security || exit 1

# 2. Performance Check  
echo "Running performance benchmarks..."
npm run audit:performance || exit 1

# 3. Component Size Check
echo "Checking component sizes..."
find src -name "*.tsx" -exec wc -l {} + | awk '$1 > 500 { print "❌ " $2 " has " $1 " lines (max 500)"; exit 1 }'

# 4. Test Coverage Check
echo "Verifying test coverage..."
npm run test:coverage | grep "All files" | awk '{ if ($4 < 80) { print "❌ Coverage " $4 "% below 80%"; exit 1 } }'

# 5. TypeScript Check
echo "TypeScript compilation check..."
npx tsc --noEmit || exit 1

# 6. Lint Check
echo "Linting check..."
npm run lint || exit 1

# 7. Linux Lockfile Check (Critical for Heroku)
echo "Checking Linux lockfile..."
npm run lockfile:linux

echo "✅ All pre-merge checks passed!"
```

### Professional Development Context Summary

This enhanced rule provides you with:

1. **Industry-Standard Architecture**: Feature-based organization, proper separation of concerns
2. **Security Best Practices**: Multi-tenant isolation, JWT security, input validation
3. **Performance Optimization**: Server-side pagination, React optimization, memory management
4. **Testing Excellence**: 80% coverage, comprehensive test strategies, E2E testing
5. **Deployment Reliability**: Cross-platform compatibility, evidence-based deployment
6. **Code Quality**: Size limits, TypeScript strict mode, error handling standards
7. **CRM Domain Expertise**: Lead lifecycle, integration patterns, call tracking
8. **Professional Workflow**: TDD methodology, systematic refactoring, documentation standards

**This rule transforms you into a professional lead developer with comprehensive context about the Crokodial CRM system, its technical challenges, and industry-standard solutions.**
description:
globs:
alwaysApply: false
---
