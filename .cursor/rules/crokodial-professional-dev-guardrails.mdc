## ‚ú® CROKODIAL CRM PRIME DIRECTIVE
> **All code must build, test, and run on macOS, Linux, and Windows (Node ‚â• 18 LTS) without manual tweaks.**  
> **Every feature must be multi-tenant secure, performant at scale (2,000+ leads), and production-ready.**
> When platform quirks arise, surface them as TODOs and supply a CI‚Äëverified fix.

---

## üö® CROKODIAL-SPECIFIC PROFESSIONAL STANDARDS

### Critical Technical Debt Priorities (MANDATORY)
1. **NEVER create monolithic components >500 lines** (current violations: Leads.tsx 6879 lines, Dialer.tsx 3506 lines)
2. **SECURITY CRITICAL: JWT tokens MUST move from localStorage to httpOnly cookies**
3. **PERFORMANCE CRITICAL: Server-side pagination required** (current client-side breaks at 500+ leads)
4. **TESTING MANDATORY: 80% coverage minimum** for all new code (current: ~0% coverage)
5. **MULTI-TENANT SECURITY: Every query MUST include tenantId/userId scope**

### Professional CRM Architecture Standards
- **Feature-Based Organization**: Group by business domain (auth/, leads/, dialer/, campaigns/, integrations/)
- **Single Responsibility**: Each component handles ONE business concern
- **API-First Design**: All business logic in services, controllers only handle HTTP
- **Type Safety**: Strict TypeScript with proper interfaces for all data models
- **Error Boundaries**: Comprehensive error handling with user-friendly messages
- **Multi-Tenant Security**: Built into every data access layer

### Crokodial Technology Stack Context
```typescript
// Current Stack (MUST maintain compatibility)
Frontend: React 18 + TypeScript + Vite + Chakra UI + React Query + Context API
Backend: Node.js + Express + TypeScript + MongoDB + Mongoose
Integrations: Twilio (calls/SMS) + Calendly + NextGen + USHA + Ringy
Deployment: Heroku (Linux) + MongoDB Atlas
Testing: Jest + Cypress (to be implemented)
```

---

## üî• ENHANCEMENT 1: INTEGRATION-SPECIFIC CONTEXT

### Twilio Integration Patterns (BUSINESS CRITICAL)
```typescript
// MANDATORY: All Twilio calls MUST include error handling and logging
const makeCall = async (phoneNumber: string, userId: string) => {
  try {
    const call = await twilio.calls.create({
      to: phoneNumber,
      from: process.env.TWILIO_PHONE_NUMBER,
      url: `${process.env.BASE_URL}/api/twilio/voice/${userId}`,
      statusCallback: `${process.env.BASE_URL}/api/twilio/status`,
      statusCallbackEvent: ['initiated', 'ringing', 'answered', 'completed'],
      timeout: 30,
      record: true
    });
    
    // MANDATORY: Log all calls for billing and analytics
    await Call.create({
      twilioSid: call.sid,
      userId,
      phoneNumber,
      status: 'initiated',
      timestamp: new Date()
    });
    
    return call;
  } catch (error) {
    // MANDATORY: Comprehensive error logging for Twilio issues
    logger.error('Twilio call failed', { phoneNumber, userId, error: error.message });
    throw new Error(`Call failed: ${error.message}`);
  }
};
```

### NextGen Webhook Security (DATA INTEGRITY CRITICAL)
```typescript
// MANDATORY: All NextGen webhooks MUST validate and deduplicate
const processNextGenWebhook = async (payload: NextGenPayload) => {
  // 1. Validate webhook signature (prevent spoofing)
  const isValid = validateNextGenSignature(payload, req.headers['x-nextgen-signature']);
  if (!isValid) throw new Error('Invalid NextGen webhook signature');
  
  // 2. Deduplicate leads (prevent duplicates)
  const existingLead = await Lead.findOne({ 
    email: payload.email, 
    phone: payload.phone 
  });
  if (existingLead) {
    logger.info('Duplicate NextGen lead skipped', { email: payload.email });
    return { status: 'duplicate', leadId: existingLead._id };
  }
  
  // 3. Assign to user based on routing rules
  const assignedUserId = await determineUserAssignment(payload);
  
  // 4. Create lead with proper source tracking
  const lead = await Lead.create({
    ...payload,
    userId: assignedUserId,
    source: 'NextGen',
    sourceData: payload,
    createdAt: new Date()
  });
  
  return { status: 'created', leadId: lead._id };
};
```

---

## üî• ENHANCEMENT 2: CURRENT ISSUE RESOLUTION PATTERNS

### Search Functionality Fix Pattern (IMMEDIATELY APPLICABLE)
```typescript
// CRITICAL: Current search is broken (client-side filtering breaks at 500+ leads)
// NEVER use getAllResults with client-side filtering
// ALWAYS use server-side search with MongoDB $regex

// ‚ùå BROKEN PATTERN (Current Leads.tsx line ~6083):
useEffect(() => {
  if (searchQuery) {
    // This breaks at 500+ leads!
    fetchLeads({ getAllResults: 'true', limit: 1000 }).then(allLeads => {
      const filtered = allLeads.filter(lead => 
        lead.name.startsWith(searchQuery) // Only startsWith, misses "Michael Anthony"
      );
    });
  }
}, [searchQuery]);

// ‚úÖ CORRECT PATTERN (Server-side search):
useEffect(() => {
  if (searchQuery.trim()) {
    setIsLoading(true);
    
    const abortController = new AbortController();
    const debounceTimeout = setTimeout(() => {
      // Server searches ALL leads with proper regex matching
      fetchLeads({ 
        search: searchQuery.trim(), // Server-side search
        page: currentPage,
        limit: 50,
        sortDirection,
        states: selectedStates,
        dispositions: selectedDispositions,
        pipelineSource: selectedPipeline
      }, { signal: abortController.signal })
      .then(response => {
        setLeads(response.data.leads);
        setTotalLeads(response.data.pagination.total);
        setIsLoading(false);
      });
    }, 300);
    
    return () => {
      clearTimeout(debounceTimeout);
      abortController.abort();
    };
  }
}, [searchQuery, currentPage, sortDirection, selectedStates, selectedDispositions, selectedPipeline]);
```

### WebSocket Authentication Fix Pattern (PRODUCTION BLOCKER)
```typescript
// CRITICAL: Current WebSocket auth fails with "JsonWebTokenError: invalid signature"
// Root cause: Inconsistent JWT_SECRET across environments

// MANDATORY: Consistent JWT handling pattern
const generateToken = (user: User) => {
  const JWT_SECRET = process.env.JWT_SECRET;
  if (!JWT_SECRET) throw new Error('JWT_SECRET environment variable required');
  
  return jwt.sign(
    { 
      userId: user._id, 
      email: user.email,
      role: user.role 
    }, 
    JWT_SECRET, 
    { 
      expiresIn: '24h',
      issuer: 'crokodial-crm',
      audience: 'crokodial-users'
    }
  );
};

// MANDATORY: WebSocket authentication middleware
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    socket.userId = decoded.userId;
    next();
  } catch (error) {
    logger.error('WebSocket auth failed', { error: error.message });
    next(new Error('Authentication failed'));
  }
});
```

---

## üî• ENHANCEMENT 3: DEPLOYMENT & BUILD RELIABILITY

### Linux Lockfile Management (HEROKU DEPLOYMENT CRITICAL)
```bash
# MANDATORY: Always run before Heroku deployment
# This prevents "Cannot find module @rollup/rollup-linux-x64-gnu" errors

pre_deploy_checklist() {
  echo "üîç Pre-deployment verification..."
  
  # 1. Linux lockfile regeneration (CRITICAL for Heroku)
  echo "Regenerating Linux lockfile..."
  npm run lockfile:linux || {
    echo "‚ùå Linux lockfile generation failed"
    exit 1
  }
  
  # 2. Security audit
  echo "Running security audit..."
  npm audit --audit-level=high || {
    echo "‚ùå Security vulnerabilities found"
    exit 1
  }
  
  # 3. TypeScript compilation check
  echo "Checking TypeScript compilation..."
  npx tsc --noEmit || {
    echo "‚ùå TypeScript compilation failed"
    exit 1
  }
  
  # 4. Test coverage verification
  echo "Verifying test coverage..."
  npm test -- --coverage --passWithNoTests || {
    echo "‚ùå Tests failed or coverage below threshold"
    exit 1
  }
  
  # 5. Build verification
  echo "Testing production build..."
  npm run build || {
    echo "‚ùå Production build failed"
    exit 1
  }
  
  echo "‚úÖ Pre-deployment checks passed"
}
```

### Production Verification Protocol (DEPLOYMENT EVIDENCE)
```bash
# MANDATORY: Run after every deployment
post_deploy_verification() {
  echo "üîç Post-deployment verification..."
  
  # 1. Health check
  HEALTH_STATUS=$(curl -s https://crokodial.com/api/health | jq -r '.status')
  if [ "$HEALTH_STATUS" != "ok" ]; then
    echo "‚ùå Health check failed: $HEALTH_STATUS"
    exit 1
  fi
  
  # 2. Database connectivity
  LEAD_COUNT=$(curl -s https://crokodial.com/api/leads?limit=1 | jq -r '.data.pagination.total')
  if [ "$LEAD_COUNT" -lt 2000 ]; then
    echo "‚ö†Ô∏è Lead count seems low: $LEAD_COUNT (expected 2000+)"
  fi
  
  # 3. Integration status
  curl -s https://crokodial.com/api/integrations/status | jq '.twilio, .nextgen, .calendly'
  
  # 4. Bundle hash verification (cache busting)
  BUNDLE_HASH=$(curl -s https://crokodial.com/index.html | grep -o "assets/index-[a-f0-9]*\.js")
  echo "Bundle hash: $BUNDLE_HASH"
  
  echo "‚úÖ Post-deployment verification completed"
}
```

---

## üî• ENHANCEMENT 4: COMPONENT REFACTORING STRATEGY

### Leads.tsx Modularization Plan (6879 LINES ‚Üí <500 EACH)
```typescript
// IMMEDIATE PRIORITY: Break down Leads.tsx into these components:

// 1. LeadListContainer.tsx (<300 lines)
const LeadListContainer = () => {
  const { leads, loading, error } = useLeadsData();
  const { filters } = useLeadFilters();
  
  if (loading) return <LeadListSkeleton />;
  if (error) return <ErrorBoundary error={error} />;
  
  return (
    <LeadListProvider>
      <LeadFilters />
      <LeadList leads={leads} />
      <LeadPagination />
    </LeadListProvider>
  );
};

// 2. LeadCard.tsx (<200 lines)
const LeadCard = ({ lead, onCall, onEdit, onDelete }: LeadCardProps) => {
  const { user } = useAuth();
  const { updateDisposition } = useLeadActions();
  
  // Verify multi-tenant security
  if (lead.userId !== user.id) return null;
  
  return (
    <Card>
      <LeadInfo lead={lead} />
      <LeadActions 
        onCall={() => onCall(lead.phone)}
        onEdit={() => onEdit(lead)}
        onDelete={() => onDelete(lead._id)}
      />
      <DispositionSelect 
        value={lead.disposition}
        onChange={(value) => updateDisposition(lead._id, value)}
      />
    </Card>
  );
};

// 3. LeadFilters.tsx (<250 lines)
const LeadFilters = () => {
  const { filters, updateFilters } = useLeadFilters();
  
  return (
    <FilterContainer>
      <SearchInput 
        value={filters.search}
        onChange={(value) => updateFilters({ search: value })}
        placeholder="Search leads..."
      />
      <StateFilter 
        selected={filters.states}
        onChange={(states) => updateFilters({ states })}
      />
      <DispositionFilter 
        selected={filters.dispositions}
        onChange={(dispositions) => updateFilters({ dispositions })}
      />
      <PipelineSourceFilter 
        selected={filters.pipelineSource}
        onChange={(source) => updateFilters({ pipelineSource: source })}
      />
    </FilterContainer>
  );
};

// 4. Custom hooks for complex logic
const useLeadsData = () => {
  const { filters, sortDirection, currentPage } = useLeadFilters();
  
  return useQuery({
    queryKey: ['leads', filters, sortDirection, currentPage],
    queryFn: () => fetchLeads({
      ...filters,
      sortDirection,
      page: currentPage,
      limit: 50
    }),
    staleTime: 30000, // 30 seconds
    refetchOnWindowFocus: false
  });
};
```

### Dialer.tsx Modularization Plan (3506 LINES ‚Üí <500 EACH)
```typescript
// IMMEDIATE PRIORITY: Break down Dialer.tsx into these components:

// 1. DialerContainer.tsx (<300 lines)
const DialerContainer = ({ lead }: { lead: Lead }) => {
  const [isDetached, setIsDetached] = useState(false);
  const [callStatus, setCallStatus] = useState<CallStatus>('idle');
  
  if (isDetached) {
    return (
      <DetachedDialerWindow 
        lead={lead}
        onClose={() => setIsDetached(false)}
      />
    );
  }
  
  return (
    <DialerProvider lead={lead}>
      <DialerHeader onDetach={() => setIsDetached(true)} />
      <CallControls />
      <CallHistory />
      <CallNotes />
    </DialerProvider>
  );
};

// 2. CallControls.tsx (<200 lines)
const CallControls = () => {
  const { lead, makeCall, endCall, callStatus } = useDialer();
  const { user } = useAuth();
  
  const handleCall = async () => {
    try {
      await makeCall(lead.phone, user.id);
      // Track call in database
      await trackCall({
        leadId: lead._id,
        userId: user.id,
        phoneNumber: lead.phone,
        timestamp: new Date()
      });
    } catch (error) {
      toast({
        title: 'Call Failed',
        description: error.message,
        status: 'error'
      });
    }
  };
  
  return (
    <CallControlsContainer>
      <CallButton 
        onClick={handleCall}
        disabled={callStatus === 'calling'}
      >
        {callStatus === 'calling' ? 'Calling...' : 'Call'}
      </CallButton>
      <EndCallButton 
        onClick={endCall}
        disabled={callStatus !== 'connected'}
      >
        End Call
      </EndCallButton>
    </CallControlsContainer>
  );
};
```

---

## üî• ENHANCEMENT 5: ERROR HANDLING & RECOVERY PATTERNS

### Comprehensive Error Boundaries (PRODUCTION STABILITY)
```typescript
// MANDATORY: Wrap all major sections with error boundaries
class CRMErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    // Log to monitoring service
    logger.error('CRM Error Boundary caught error', {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      userId: this.props.userId,
      timestamp: new Date().toISOString()
    });
    
    // Send to error tracking service (Sentry, LogRocket, etc.)
    if (window.Sentry) {
      window.Sentry.captureException(error, {
        contexts: {
          react: {
            componentStack: errorInfo.componentStack
          }
        }
      });
    }
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <ErrorFallback 
          error={this.state.error}
          resetError={() => this.setState({ hasError: false, error: null })}
        />
      );
    }
    
    return this.props.children;
  }
}

// Usage in main components
const App = () => (
  <CRMErrorBoundary userId={user?.id}>
    <Router>
      <AuthProvider>
        <CRMErrorBoundary>
          <LeadsPage />
        </CRMErrorBoundary>
        <CRMErrorBoundary>
          <DialerComponent />
        </CRMErrorBoundary>
      </AuthProvider>
    </Router>
  </CRMErrorBoundary>
);
```

### Loading State Management (UX CRITICAL)
```typescript
// MANDATORY: Prevent infinite loading states (current issue in AuthContext)
const useTimeoutLoading = (loadingState: boolean, timeoutMs: number = 10000) => {
  const [timedOut, setTimedOut] = useState(false);
  
  useEffect(() => {
    if (!loadingState) {
      setTimedOut(false);
      return;
    }
    
    const timeout = setTimeout(() => {
      setTimedOut(true);
      logger.warn('Loading timeout reached', { timeoutMs });
    }, timeoutMs);
    
    return () => clearTimeout(timeout);
  }, [loadingState, timeoutMs]);
  
  return { loading: loadingState && !timedOut, timedOut };
};

// Usage in components
const LeadsPage = () => {
  const { data: leads, isLoading, error } = useLeadsQuery();
  const { loading, timedOut } = useTimeoutLoading(isLoading, 15000);
  
  if (timedOut) {
    return (
      <ErrorState 
        title="Loading Timeout"
        message="The request is taking longer than expected. Please refresh the page."
        onRetry={() => window.location.reload()}
      />
    );
  }
  
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorState error={error} />;
  
  return <LeadsList leads={leads} />;
};
```

---

## AGENTIC MODES (Enhanced for CRM Development)

### **Planner Mode**: CRM-Focused Analysis
- **MANDATORY**: Before any work, assess current technical debt violations
- **Component Size Check**: `find src -name "*.tsx" -exec wc -l {} + | awk '$1 > 500'`
- **Security Audit**: Verify JWT storage, API key exposure, multi-tenant isolation
- **Performance Analysis**: Check for client-side filtering, missing pagination, memory leaks
- **Integration Status**: Verify Twilio, NextGen, Calendly, USHA, Ringy functionality
- **Test Coverage**: Ensure 80% minimum coverage for new code
- **Architecture Mapping**: Document feature-based organization progress

### **Executor Mode**: Stepwise Implementation
- **MANDATORY**: One component refactoring per session (max 500 lines)
- **Security First**: Implement multi-tenant checks in every new query
- **Performance Benchmarks**: Measure and record response times
- **Error Handling**: Comprehensive try/catch with user-friendly messages
- **Testing**: Write tests before implementation (TDD)
- **Documentation**: Update API docs and component interfaces
- **Deployment Prep**: Linux lockfile, security audit, build verification

---

## 2. CROKODIAL DEPLOYMENT & VERIFICATION PROTOCOL

### Production Deployment Evidence (Heroku-Specific)
```bash
# Pre-Deployment Checklist
- [ ] npm run lockfile:linux executed (CRITICAL for Heroku)
- [ ] npm audit shows no critical/high vulnerabilities
- [ ] npm test passes with 80%+ coverage  
- [ ] npm run lint passes with zero errors
- [ ] TypeScript compilation successful (tsc --noEmit)
- [ ] Multi-tenant security tests pass
- [ ] Performance benchmarks within acceptable limits

# Deployment Verification Commands
curl -s https://crokodial.com/api/health | jq '.'
curl -s https://crokodial.com/api/leads?limit=1 | jq '.data[0]'
curl -s https://crokodial.com/index.html | grep -o "assets/index-[a-f0-9]*\.js"

# Database & Integration Verification
echo "db.leads.countDocuments()" | mongo $MONGODB_URI
node scripts/test-twilio-integration.js
node scripts/test-nextgen-webhook.js
```

### CRM-Specific Health Checks
- **Lead Import Pipeline**: Verify NextGen webhook processing
- **Twilio Integration**: Test call/SMS functionality  
- **Database Performance**: Query response times under load
- **Multi-Tenant Isolation**: Verify user data separation
- **Memory Usage**: Check for memory leaks in long-running sessions
- **Search Performance**: Verify server-side search with 2,000+ leads

**Record all evidence in `.cursor/scratchpad.md`**

---

## 3. CROKODIAL WORKFLOW & TASK MANAGEMENT

### Enhanced Scratchpad Structure
```markdown
# .cursor/scratchpad.md

## Current Context
- Lead Count: [X] leads in database
- Active Integrations: [NextGen, Twilio, Calendly status]
- Performance Metrics: [Lead list render time, search response time]
- Security Status: [JWT storage method, API key exposure check]

## Background & Motivation
[Current feature/bug context]

## Technical Debt Analysis
- Monolithic Components: [List files >500 lines]
- Security Vulnerabilities: [JWT, API keys, rate limiting status]
- Performance Issues: [Client-side filtering, pagination, memory leaks]
- Testing Coverage: [Current % coverage, missing test areas]

## Task Breakdown (Tiny, Verifiable Steps)
- [ ] [Step 1] - Success Criteria: [Specific measurable outcome]
- [ ] [Step 2] - Success Criteria: [Specific measurable outcome]

## Multi-Tenant Security Checklist
- [ ] All queries include proper tenant scoping
- [ ] No cross-tenant data leakage possible
- [ ] Authentication/authorization properly implemented

## Executor Status & Blockers
[Current implementation status, any blockers requiring planner input]
```

### CRM Development Workflow (TDD-Enhanced)
```typescript
// 1. Write failing test for CRM functionality
describe('Lead Management', () => {
  it('should create lead with proper user scoping', async () => {
    const user = await createTestUser();
    const leadData = { name: 'John Doe', phone: '+1234567890' };
    
    const lead = await createLead(leadData, user.id);
    
    expect(lead.userId).toBe(user.id);
    expect(lead.name).toBe('John Doe');
  });
  
  it('should prevent cross-tenant access', async () => {
    const userA = await createTestUser();
    const userB = await createTestUser();
    const lead = await createLead({ name: 'Test' }, userA.id);
    
    const result = await getLeadAsUser(lead._id, userB.id);
    
    expect(result).toBeNull(); // Should not access other user's lead
  });
});

// 2. Implement minimal code to pass test
const createLead = async (data: LeadData, userId: string) => {
  return Lead.create({ ...data, userId });
};

// 3. Refactor with proper error handling
const createLead = async (data: LeadData, userId: string) => {
  try {
    const lead = await Lead.create({ 
      ...data, 
      userId,
      createdAt: new Date(),
      source: data.source || 'Manual'
    });
    
    // Log for audit trail
    await AuditLog.create({
      action: 'lead_created',
      userId,
      resourceId: lead._id,
      timestamp: new Date()
    });
    
    return lead;
  } catch (error) {
    logger.error('Lead creation failed', { data, userId, error });
    throw new Error(`Failed to create lead: ${error.message}`);
  }
};
```

---

## 4. CRM SECURITY & QUALITY GUARDRAILS

### Critical Security Fixes (Immediate)
- **JWT Storage**: Move from localStorage to httpOnly cookies with CSRF protection
- **API Keys**: Remove from code, use environment variables only
- **Input Validation**: Zod schemas for all API endpoints
- **Rate Limiting**: Implement on auth and lead import endpoints
- **Audit Logging**: Track all lead access, modification, deletion

### Code Quality Standards
- **File Size Limit**: 500 lines max (current violations must be refactored)
- **Test Coverage**: 80% minimum for new code, 60% for existing
- **TypeScript Strict**: No `any` types, proper interfaces for all data
- **Error Handling**: Proper try/catch with user-friendly error messages
- **Performance**: Server-side pagination, React.memo for expensive renders

```typescript
// CRM Data Validation Example
import { z } from 'zod';

const LeadSchema = z.object({
  name: z.string().min(1).max(100),
  email: z.string().email().optional(),
  phone: z.string().regex(/^\+?[\d\s\-\(\)]{10,}$/),
  disposition: z.enum(['New', 'Contacted', 'Qualified', 'Closed']),
  source: z.enum(['NextGen', 'Marketplace', 'Manual']),
  userId: z.string().min(1) // MANDATORY for multi-tenant security
});

// Multi-Tenant Data Access (MANDATORY PATTERN)
import rateLimit from 'express-rate-limit';

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // limit each IP to 5 requests per windowMs
  message: 'Too many login attempts, please try again later'
});

// Multi-Tenant Data Access (MANDATORY PATTERN)
class LeadService {
  async getLeads(userId: string, filters: LeadFilters) {
    // ALWAYS include userId in query - NO EXCEPTIONS
    const query = { userId, ...filters };
    return Lead.find(query);
  }
  
  async updateLead(leadId: string, userId: string, updates: LeadUpdates) {
    // ALWAYS verify ownership before update
    const lead = await Lead.findOne({ _id: leadId, userId });
    if (!lead) throw new NotFoundError('Lead not found');
    return Lead.updateOne({ _id: leadId, userId }, updates);
  }
}
```

### Code Quality Standards (Enforced)
- **Component Size**: 500 lines maximum (immediate refactoring required for violations)
- **Function Complexity**: Max 15 cyclomatic complexity
- **Test Coverage**: 80% minimum for new code, 60% for existing (with improvement plan)
- **TypeScript Strict**: No `any` types, proper interfaces for all data structures
- **Error Handling**: Comprehensive try/catch with user-friendly error messages
- **Performance**: Sub-200ms API response times, sub-100ms UI interactions

---

## 5. CROKODIAL ARCHITECTURE PATTERNS

### Feature-Based Directory Structure (MANDATORY)
```typescript
src/features/
‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ components/     # LoginForm, AuthGuard
‚îÇ   ‚îú‚îÄ‚îÄ hooks/          # useAuth, useLogin
‚îÇ   ‚îú‚îÄ‚îÄ services/       # authService, tokenService
‚îÇ   ‚îú‚îÄ‚îÄ types/          # User, AuthState interfaces
‚îÇ   ‚îî‚îÄ‚îÄ utils/          # tokenUtils, authValidation
‚îú‚îÄ‚îÄ leads/
‚îÇ   ‚îú‚îÄ‚îÄ components/     # LeadCard, LeadList, LeadFilters
‚îÇ   ‚îú‚îÄ‚îÄ hooks/          # useLeads, useLeadActions
‚îÇ   ‚îú‚îÄ‚îÄ services/       # leadService, searchService
‚îÇ   ‚îú‚îÄ‚îÄ types/          # Lead, LeadFilters interfaces
‚îÇ   ‚îî‚îÄ‚îÄ utils/          # leadValidation, leadFormatting
‚îú‚îÄ‚îÄ dialer/
‚îÇ   ‚îú‚îÄ‚îÄ components/     # CallControls, CallHistory
‚îÇ   ‚îú‚îÄ‚îÄ hooks/          # useDialer, useCallTracking
‚îÇ   ‚îú‚îÄ‚îÄ services/       # twilioService, callService
‚îÇ   ‚îú‚îÄ‚îÄ types/          # Call, CallStatus interfaces
‚îÇ   ‚îî‚îÄ‚îÄ utils/          # phoneFormatting, callUtils
‚îú‚îÄ‚îÄ integrations/
‚îÇ   ‚îú‚îÄ‚îÄ nextgen/        # NextGen webhook handling
‚îÇ   ‚îú‚îÄ‚îÄ twilio/         # Twilio call management
‚îÇ   ‚îú‚îÄ‚îÄ calendly/       # Appointment booking
‚îÇ   ‚îî‚îÄ‚îÄ shared/         # Common integration utilities
‚îî‚îÄ‚îÄ shared/
    ‚îú‚îÄ‚îÄ components/     # Button, Modal, LoadingSpinner
    ‚îú‚îÄ‚îÄ hooks/          # useApi, useLocalStorage
    ‚îú‚îÄ‚îÄ services/       # httpClient, errorService
    ‚îú‚îÄ‚îÄ types/          # ApiResponse, ErrorState
    ‚îî‚îÄ‚îÄ utils/          # formatters, validators

// Example Feature Module (leads/index.ts)
export { LeadCard, LeadList, LeadFilters } from './components';
export { useLeads, useLeadActions } from './hooks';
export { leadService } from './services';
export type { Lead, LeadFilters, LeadActions } from './types';
```

### CRM Component Architecture (Professional Standards)
```typescript
// Example: Professional Lead Component Structure
const LeadsPageContainer = () => {
  const { leads, loading, error } = useLeadsData();
  const { filters, setFilters } = useLeadFilters();
  const { selectedLeads, actions } = useLeadActions();

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorBoundary error={error} />;

  return (
    <LeadsPageLayout>
      <LeadFilters filters={filters} onChange={setFilters} />
      <LeadList 
        leads={leads} 
        selectedLeads={selectedLeads}
        onAction={actions}
      />
      <LeadPagination />
    </LeadsPageLayout>
  );
};

// Each component < 200 lines, single responsibility, fully tested
```

---

## 6. CROKODIAL TESTING STRATEGY

### Testing Requirements (80% Coverage Minimum)
```typescript
// Component Testing (React Testing Library + Jest)
describe('LeadCard', () => {
  it('displays lead information correctly', () => {
    const lead = createMockLead({ 
      name: 'John Doe', 
      phone: '+1234567890',
      userId: 'user123'
    });
    
    render(<LeadCard lead={lead} />, {
      wrapper: ({ children }) => (
        <AuthProvider user={{ id: 'user123' }}>
          {children}
        </AuthProvider>
      )
    });
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('+1234567890')).toBeInTheDocument();
  });

  it('prevents cross-tenant data access', () => {
    const userALead = createMockLead({ userId: 'userA' });
    
    render(<LeadCard lead={userALead} />, {
      wrapper: ({ children }) => (
        <AuthProvider user={{ id: 'userB' }}>
          {children}
        </AuthProvider>
      )
    });
    
    expect(screen.queryByText(userALead.name)).not.toBeInTheDocument();
  });

  it('handles call action correctly', async () => {
    const mockCall = jest.fn();
    const lead = createMockLead();
    
    render(<LeadCard lead={lead} onCall={mockCall} />);
    
    await user.click(screen.getByRole('button', { name: /call/i }));
    expect(mockCall).toHaveBeenCalledWith(lead.phone);
  });
});

// Integration Testing (Cypress)
describe('Lead Management Flow', () => {
  it('creates, edits, and deletes leads with proper security', () => {
    cy.login('user@example.com', 'password');
    
    // Create lead
    cy.visit('/leads');
    cy.get('[data-cy=add-lead]').click();
    cy.get('[data-cy=lead-name]').type('John Doe');
    cy.get('[data-cy=lead-phone]').type('+1234567890');
    cy.get('[data-cy=submit]').click();
    
    // Verify lead appears in list
    cy.contains('John Doe').should('be.visible');
    
    // Test multi-tenant security
    cy.login('otheruser@example.com', 'password');
    cy.visit('/leads');
    cy.contains('John Doe').should('not.exist');
  });
});

// Performance Testing
describe('Performance Benchmarks', () => {
  it('loads lead list within 500ms for 1000 leads', () => {
    const start = performance.now();
    
    render(<LeadList leads={create1000MockLeads()} />);
    
    const end = performance.now();
    expect(end - start).toBeLessThan(500);
  });
});
```

### Multi-Tenant Security Testing (MANDATORY)
```typescript
describe('Multi-Tenant Security', () => {
  it('prevents cross-tenant data access in API', async () => {
    const userA = await createTestUser();
    const userB = await createTestUser();
    const leadA = await createLead({ name: 'User A Lead' }, userA.id);
    
    const response = await request(app)
      .get(`/api/leads/${leadA._id}`)
      .set('Authorization', `Bearer ${userB.token}`)
      .expect(404); // Should not find lead belonging to different user
  });
  
  it('scopes database queries by user', async () => {
    const userA = await createTestUser();
    const userB = await createTestUser();
    
    await createLead({ name: 'Lead A1' }, userA.id);
    await createLead({ name: 'Lead A2' }, userA.id);
    await createLead({ name: 'Lead B1' }, userB.id);
    
    const userALeads = await Lead.find({ userId: userA.id });
    const userBLeads = await Lead.find({ userId: userB.id });
    
    expect(userALeads).toHaveLength(2);
    expect(userBLeads).toHaveLength(1);
    expect(userALeads.every(lead => lead.userId === userA.id)).toBe(true);
  });
});
```

---

## 7. CROKODIAL COMMON PITFALLS (CRITICAL AVOIDANCE)

### Deployment Pitfalls (HEROKU-SPECIFIC)
- ‚ùå **NEVER deploy without Linux lockfile**: Always run `npm run lockfile:linux`
- ‚ùå **NEVER ignore bundle hash mismatch**: Verify CDN cache invalidation
- ‚ùå **NEVER skip health checks**: Verify API endpoints after deployment
- ‚ùå **NEVER deploy with failing tests**: 80% coverage minimum required
- ‚ùå **NEVER hardcode environment variables**: Use Heroku config vars

### Development Pitfalls (CODE QUALITY)
- ‚ùå **NEVER create components >500 lines**: Break down immediately
- ‚ùå **NEVER use client-side filtering >100 records**: Server-side pagination required
- ‚ùå **NEVER store JWT in localStorage**: Use httpOnly cookies with CSRF protection
- ‚ùå **NEVER skip multi-tenant checks**: Every query MUST include userId
- ‚ùå **NEVER hardcode API keys**: Environment variables only
- ‚ùå **NEVER skip error boundaries**: Leads to white screen of death

### CRM-Specific Pitfalls (BUSINESS CRITICAL)
- ‚ùå **NEVER process leads without deduplication**: Implement proper lead matching
- ‚ùå **NEVER allow unlimited imports**: Rate limiting prevents system overload
- ‚ùå **NEVER skip disposition validation**: Data consistency is critical
- ‚ùå **NEVER ignore call tracking**: Affects billing and analytics
- ‚ùå **NEVER skip backup verification**: Customer data loss is unacceptable

---

## GOLDEN RULE (CROKODIAL ENHANCED)

> **Merge only when ALL conditions met:**  
> ‚úÖ tests 80%+ coverage ¬∑ ‚úÖ multi-tenant security verified ¬∑ ‚úÖ performance benchmarks met  
> ‚úÖ component size <500 lines ¬∑ ‚úÖ TypeScript strict compliance ¬∑ ‚úÖ error handling comprehensive  
> ‚úÖ code map updated ¬∑ ‚úÖ API documentation current ¬∑ ‚úÖ deployment evidence recorded  
> ‚úÖ cross-platform compatibility ¬∑ ‚úÖ Linux lockfile updated ¬∑ ‚úÖ security audit passed

### Crokodial-Specific Merge Gates (MANDATORY)
```bash
# Pre-Merge Verification Script
#!/bin/bash
echo "üîç Crokodial Pre-Merge Verification"

# 1. Security Check
echo "Checking multi-tenant security..."
npm run test:security || exit 1

# 2. Performance Check  
echo "Running performance benchmarks..."
npm run audit:performance || exit 1

# 3. Component Size Check
echo "Checking component sizes..."
find src -name "*.tsx" -exec wc -l {} + | awk '$1 > 500 { print "‚ùå " $2 " has " $1 " lines (max 500)"; exit 1 }'

# 4. Test Coverage Check
echo "Verifying test coverage..."
npm run test:coverage | grep "All files" | awk '{ if ($4 < 80) { print "‚ùå Coverage " $4 "% below 80%"; exit 1 } }'

# 5. TypeScript Check
echo "TypeScript compilation check..."
npx tsc --noEmit || exit 1

# 6. Lint Check
echo "Linting check..."
npm run lint || exit 1

# 7. Linux Lockfile Check (Critical for Heroku)
echo "Checking Linux lockfile..."
npm run lockfile:linux

# 8. Integration Tests
echo "Running integration tests..."
npm run test:integration || exit 1

# 9. Build Verification
echo "Testing production build..."
npm run build || exit 1

# 10. Security Audit
echo "Running security audit..."
npm audit --audit-level=high || exit 1

echo "‚úÖ All pre-merge checks passed!"
```

### Enhanced Package Scripts (PRODUCTION-READY)
```json
{
  "scripts": {
    "gen:map": "depcruiser src --output-type dot | dot -Tsvg -o docs/dependency-graph.svg",
    "gen:docs": "typedoc --entryPoints src --out docs/site",
    "gen:api-docs": "swagger-jsdoc -d docs/swagger.json src/routes/*.ts",
    "audit:security": "npm audit --audit-level=high && snyk test",
    "audit:performance": "lighthouse-ci autorun --config=.lighthouserc.json",
    "audit:multi-tenant": "node scripts/audit-tenant-isolation.js",
    "test:unit": "jest --coverage --passWithNoTests",
    "test:integration": "cypress run --config baseUrl=http://localhost:5173",
    "test:security": "node scripts/test-tenant-isolation.js",
    "test:performance": "node scripts/performance-benchmarks.js",
    "lockfile:linux": "./scripts/fix-lockfile-for-linux.sh",
    "deploy:staging": "make deploy-staging",
    "deploy:prod": "make deploy-prod",
    "verify:deployment": "node scripts/verify-deployment.js",
    "fix:search": "node scripts/fix-search-implementation.js",
    "refactor:leads": "node scripts/refactor-leads-component.js",
    "refactor:dialer": "node scripts/refactor-dialer-component.js"
  }
}
```

---

## üéØ IMMEDIATE ACTION ITEMS (NEXT SESSION)

### Priority 1: Search Fix (PRODUCTION BLOCKER)
- [ ] Replace client-side search in Leads.tsx (line ~6083) with server-side implementation
- [ ] Test with "anthony" search to verify substring matching works
- [ ] Verify searches ALL 2,182+ leads (not limited to 500)

### Priority 2: Component Refactoring (TECHNICAL DEBT)
- [ ] Break down Leads.tsx (6879 lines) into <500 line components
- [ ] Break down Dialer.tsx (3506 lines) into <500 line components
- [ ] Implement feature-based directory structure

### Priority 3: Security Hardening (CRITICAL VULNERABILITIES)
- [ ] Migrate JWT from localStorage to httpOnly cookies
- [ ] Move API keys to environment variables
- [ ] Implement rate limiting on auth endpoints
- [ ] Add comprehensive input validation with Zod schemas

### Priority 4: Testing Implementation (PROFESSIONAL STANDARD)
- [ ] Set up Jest + React Testing Library
- [ ] Implement Cypress for E2E testing
- [ ] Create multi-tenant security test suite
- [ ] Achieve 80% test coverage minimum

### Priority 5: Performance Optimization (SCALE READINESS)
- [ ] Implement React.memo for expensive renders
- [ ] Add virtual scrolling for large lead lists
- [ ] Optimize MongoDB queries with proper indexing
- [ ] Fix memory leaks in long-running sessions

*This enhanced rule provides god-like professional developer context and will ensure seamless completion of the Crokodial CRM project with zero confusion and maximum efficiency.*

---

## üîÑ Lead Import CSV Standards: NextGen vs. Marketplace

**CRITICAL:** To ensure seamless, automated, and error-free lead imports, this repo distinguishes between **NextGen** and **Marketplace** CSV formats. Agents, contributors, and import code must always check the format and apply the correct mapping/parsing logic.

### 1. NextGen CSV Format

**File Naming Pattern:**  
`purchases-YYYY-MM-DD-to-YYYY-MM-DD.csv` or similar date-ranged naming.

**Header Row (42 columns, exact order):**
```csv
created_at,purchase_id,product,lead_id,vendor_id,vendor_name,vertical_id,account_id,account_name,campaign_id,campaign_name,bid_type,first_name,last_name,phone,street_1,street_2,email,city,state,zipcode,dob,gender,height,household_size,household_income,weight,military,pregnant,tobacco_user,has_prescription,has_medicare_parts_a_b,has_medical_condition,medical_conditions,insurance_timeframe,price,status,disposition,call_log_id,call_duration,source_hash,data_source_hash,sub_id_hash
```

**Column Conventions:**
- **Exact order required** - no column reordering allowed
- String fields: unquoted unless containing commas (then double quotes)
- Numeric fields: `price`, `height`, `weight`, `call_duration` (integer/decimal)
- Boolean fields: `true`/`false` (never 1/0)
- Array fields: JSON serialized (`[]` or `["diabetes","heart_disease"]`)
- Empty fields: blank (`,, `)
- Dates: ISO 8601 (`YYYY-MM-DD` or `YYYY-MM-DDTHH:MM:SS.sssZ`)
- **üîë CRITICAL:** `source_hash`, `data_source_hash`, `sub_id_hash` are **ONLY** in NextGen leads
- Used for deduplication, tracking, and source code mapping

**Example NextGen Row:**
```csv
2025-07-18T14:06:37.359Z,01K0EXQFSFXS9Y54EBDRTJCJQD,ad,D-V6FJ-FDYD,nextgenleads,NextGen Leads,health_insurance,GRF-981-168,Link Pellow,01JXXNQFBDDB87MBFS97Q2WFR0,Randy Bobandy,exclusive,Lynette,Boley,8634562968,511 North Dolphin,,nboley1765@comcast.net,Placida,FL,33946,1971-01-13,female,65,4,"$97,000 or Over",115,false,false,false,true,,false,[],Unknown,5,complete,,,,yBXw2,yBXw2,1PpBIL
```

### 2. Marketplace CSV Format

**File Naming Pattern:**  
`lead-report-*.csv` or `marketplace-*.csv`

**Header Row (22 columns, exact order):**
```csv
leadID,created,email,primaryPhone,firstName,lastName,dateOfBirth,addressOne,addressTwo,addressThree,city,state,postalCode,income,age,household,gender,trustedFormCertID,jornayaLeadID,crmLastCallUsername,crmLastOfCallHistoryNameLastFirst,campaignName
```

**Column Conventions:**
- **Exact order required** - no column reordering allowed
- Dates: Often `MM-DD-YYYY HH:MM:SS` (NOT ISO) - requires conversion
- Empty values: blank fields
- No complex/array fields
- **üîë CRITICAL:** Marketplace leads **NEVER** contain `source_hash` columns
- Uniqueness: Based on `leadID` field
- Optional fields: `trustedFormCertID`, `jornayaLeadID` may be blank
- Source info: Usually in `campaignName` field

**Example Marketplace Row:**
```csv
c84dbe9c-903c-4492-97dc-0e81575141a4,06-19-2025 22:07:11,rosee0306@yahoo.com,9545881042,Rosemarie,Eckhardt,03-06-1979,141 NW 28th St,,,Pompano Beach,FL,33064,55000,46,0,Male,ba81b1a2075e403716fd2082260b4a3826a7ef4d,,,,GOOD JOB LARRY
```

### 3. Import Logic Requirements

**üö® MANDATORY HEADER VALIDATION:**
```typescript
// Always validate header before parsing
const isNextGenFormat = headers.includes('source_hash') && headers.includes('data_source_hash');
const isMarketplaceFormat = headers.includes('leadID') && headers.includes('trustedFormCertID');

if (isNextGenFormat) {
  // Use: import-nextgen-today.ts, nextgenDeduplicationService.ts
} else if (isMarketplaceFormat) {
  // Use: marketplace import logic
} else {
  throw new Error('Unknown CSV format - header validation failed');
}
```

**üîß CRITICAL IMPLEMENTATION RULES:**
1. **Header Check First:** Always validate CSV format before parsing any rows
2. **Date Normalization:** Convert all dates to ISO 8601 internally
3. **No Column Changes:** Never add/remove/reorder columns without:
   - Updating TypeScript definitions (`types/Lead.ts`)
   - Updating field mappers and validation
   - Updating import scripts and tests
   - Regenerating code map (`npm run gen:map`)
4. **Error Handling:** Surface TODO for unknown formats before proceeding
5. **Testing:** All CSV changes require test coverage for both formats

**üéØ SOURCE CODE MAPPING:**
- **NextGen leads:** `sourceCode` = `source_hash` field (primary source tracking)
- **Marketplace leads:** `sourceCode` = derived from `campaignName` or defaults to "Marketplace"
- **Never mix formats** in a single import operation

### 4. Format Detection & Validation

**Quick Reference Table:**
| CSV Source   | Filename Pattern         | Header Signature (first 3 cols)       | Date Format      | Hash Columns Present |
|--------------|-------------------------|----------------------------------------|------------------|---------------------|
| NextGen      | purchases-YYYY-MM-DD... | created_at, purchase_id, product       | ISO8601          | ‚úÖ source_hash, data_source_hash, sub_id_hash |
| Marketplace  | lead-report-*.csv       | leadID, created, email                 | MM-DD-YYYY HH:MM | ‚ùå Never has hash columns |

**üîç VALIDATION CHECKLIST:**
- [ ] Header matches expected format exactly
- [ ] Column count matches specification (42 for NextGen, 22 for Marketplace)
- [ ] Required columns present and in correct order
- [ ] Date formats validated and converted to ISO
- [ ] Hash columns present ONLY in NextGen format
- [ ] Import script selected based on format detection
- [ ] Error handling for malformed/unknown formats

---

**‚ö†Ô∏è PRODUCTION SAFETY:**
Any changes to CSV structure, column order, or field mappings must be tested in staging with real data samples before production deployment. Always maintain backward compatibility and document format changes in this section.

---

## üíé NextGen Premium Listing Deduplication Logic

**CRITICAL BUSINESS RULE:** NextGen sends **TWO separate files per purchase** that must be merged into a single lead record. This is essential for accurate pricing and preventing duplicate leads.

### üîÑ The NextGen Dual-File System

**File 1: Main Lead Record**
- Contains full lead data (name, phone, address, etc.)
- Has base price (e.g., $45 for data leads)
- Product type: `"data"` (main lead information)

**File 2: Premium Listing Record**  
- Contains minimal data (same lead_id, basic info)
- Has upsell price: `$5` (always $5 for premium listing)
- Product type: `"ad"` (premium listing upsell)

### üéØ Required Deduplication Logic

**MANDATORY PROCESSING RULES:**

1. **Identify Related Records:**
   ```typescript
   // Both records share the same lead_id but different product types
   const mainLead = record.product === 'data';
   const premiumListing = record.product === 'ad' && record.price === 5;
   ```

2. **Merge Strategy:**
   ```typescript
   if (existingLead && isPremiumListing) {
     // Add premium price to existing lead
     const totalPrice = existingLead.price + premiumRecord.price; // base + $5
     
     // Update lead with combined price
     await Lead.findByIdAndUpdate(existingLead._id, {
       $set: {
         price: totalPrice,
         notes: `${existingLead.notes}\nüíé Premium Listing Applied: +$${premiumRecord.price} = $${totalPrice} total`
       }
     });
     
     // DO NOT create separate lead record for premium listing
     return; // Discard the premium listing record
   }
   ```

3. **Processing Order Handling:**
   - **Main Lead First:** Create lead, then merge premium when it arrives
   - **Premium First:** Create placeholder, replace with main lead data when it arrives
   - **Never create two separate leads for the same lead_id**

### üîß Implementation Requirements

**CRITICAL CODE PATTERNS:**

```typescript
// In nextgenDeduplicationService.ts or similar
export async function processNextGenRecord(record: NextGenRecord) {
  const existingLead = await Lead.findOne({ 
    lead_id: record.lead_id,
    source: 'NextGen' 
  });

  const isMainLead = record.product === 'data';
  const isPremiumListing = record.product === 'ad' && record.price === 5;

  if (existingLead && isPremiumListing) {
    // MERGE: Add premium price to existing main lead
    await mergePremiumListing(existingLead, record);
    return { action: 'merged', leadId: existingLead._id };
  }
  
  if (existingLead && isMainLead) {
    // REPLACE: Main lead data overwrites premium placeholder
    await replaceWithMainLead(existingLead, record);
    return { action: 'replaced', leadId: existingLead._id };
  }
  
  // CREATE: First record for this lead_id
  const newLead = await createNewLead(record);
  return { action: 'created', leadId: newLead._id };
}
```

### üìä Expected Results

**‚úÖ CORRECT OUTCOME:**
- **One lead record** in the system per purchase
- **Combined pricing:** Base price + $5 premium = Total price
- **Complete data:** Full lead information from main record
- **Clear audit trail:** Notes showing premium listing was applied

**‚ùå INCORRECT OUTCOMES TO PREVENT:**
- Two separate lead records for same purchase
- Missing premium pricing (only base price)
- Premium listing without main lead data
- Duplicate charges or billing issues

### üö® Critical Validation Checklist

**BEFORE DEPLOYING NEXTGEN CHANGES:**
- [ ] Test with both processing orders (main‚Üípremium, premium‚Üímain)
- [ ] Verify no duplicate leads created for same lead_id
- [ ] Confirm pricing is correctly summed (base + $5)
- [ ] Check notes field shows premium application
- [ ] Validate deduplication service handles edge cases
- [ ] Test with real NextGen webhook payloads
- [ ] Verify database constraints prevent duplicate lead_ids

### üîç Debugging & Monitoring

**LOG WHAT MATTERS:**
```typescript
logger.info('NextGen deduplication decision', {
  leadId: record.lead_id,
  product: record.product,
  price: record.price,
  action: 'merged|replaced|created',
  totalPrice: finalLead.price,
  service: 'nextgen-deduplication'
});
```

**METRICS TO TRACK:**
- Merge success rate (should be ~50% for premium listings)
- Duplicate lead detection (should be 0)
- Average final price (should be base + $5 for premium purchases)
- Processing order variations

---

**‚ö†Ô∏è BUSINESS IMPACT:**
Incorrect implementation of this logic results in:
- **Revenue tracking errors** (double-counting or under-counting)
- **Lead management confusion** (duplicate entries)
- **Client billing issues** (incorrect pricing)
- **Data integrity problems** (incomplete lead records)

This deduplication logic is **mission-critical** for NextGen lead processing and must be thoroughly tested before any changes to the import system.
